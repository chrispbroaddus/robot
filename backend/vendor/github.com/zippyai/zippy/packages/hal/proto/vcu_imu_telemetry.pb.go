// Code generated by protoc-gen-go. DO NOT EDIT.
// source: packages/hal/proto/vcu_imu_telemetry.proto

package hal

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import core "github.com/zippyai/zippy/packages/core/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// / An IMU frame.
type VCUIMUFrame struct {
	// Three axis gyroscope rate data (radians/sec).
	GyroX float32 `protobuf:"fixed32,1,opt,name=gyro_x,json=gyroX" json:"gyro_x,omitempty"`
	GyroY float32 `protobuf:"fixed32,2,opt,name=gyro_y,json=gyroY" json:"gyro_y,omitempty"`
	GyroZ float32 `protobuf:"fixed32,3,opt,name=gyro_z,json=gyroZ" json:"gyro_z,omitempty"`
	// Three axis accelerometer data (meters/second^2).
	AccelX float32 `protobuf:"fixed32,4,opt,name=accel_x,json=accelX" json:"accel_x,omitempty"`
	AccelY float32 `protobuf:"fixed32,5,opt,name=accel_y,json=accelY" json:"accel_y,omitempty"`
	AccelZ float32 `protobuf:"fixed32,6,opt,name=accel_z,json=accelZ" json:"accel_z,omitempty"`
}

func (m *VCUIMUFrame) Reset()                    { *m = VCUIMUFrame{} }
func (m *VCUIMUFrame) String() string            { return proto.CompactTextString(m) }
func (*VCUIMUFrame) ProtoMessage()               {}
func (*VCUIMUFrame) Descriptor() ([]byte, []int) { return fileDescriptor25, []int{0} }

func (m *VCUIMUFrame) GetGyroX() float32 {
	if m != nil {
		return m.GyroX
	}
	return 0
}

func (m *VCUIMUFrame) GetGyroY() float32 {
	if m != nil {
		return m.GyroY
	}
	return 0
}

func (m *VCUIMUFrame) GetGyroZ() float32 {
	if m != nil {
		return m.GyroZ
	}
	return 0
}

func (m *VCUIMUFrame) GetAccelX() float32 {
	if m != nil {
		return m.AccelX
	}
	return 0
}

func (m *VCUIMUFrame) GetAccelY() float32 {
	if m != nil {
		return m.AccelY
	}
	return 0
}

func (m *VCUIMUFrame) GetAccelZ() float32 {
	if m != nil {
		return m.AccelZ
	}
	return 0
}

// / Describes data reported from the IMU.
type VCUIMUTelemetry struct {
	// / Timestamp describing when we started this batch of IMU measurements.
	PeriodStartTimestamp *core.SystemTimestamp `protobuf:"bytes,1,opt,name=period_start_timestamp,json=periodStartTimestamp" json:"period_start_timestamp,omitempty"`
	// / Timestamp describing when we ended this batch of IMU measurements.
	PeriodEndTimestamp *core.SystemTimestamp `protobuf:"bytes,2,opt,name=period_end_timestamp,json=periodEndTimestamp" json:"period_end_timestamp,omitempty"`
	// / Restricted in options file to max_count: 31
	// / For now, we don't have individual timestamps for each IMU frame.
	// / Hopefully we can assume the frames are evenly spread between the
	// / period start and end timestamps.
	Frames []*VCUIMUFrame `protobuf:"bytes,3,rep,name=frames" json:"frames,omitempty"`
}

func (m *VCUIMUTelemetry) Reset()                    { *m = VCUIMUTelemetry{} }
func (m *VCUIMUTelemetry) String() string            { return proto.CompactTextString(m) }
func (*VCUIMUTelemetry) ProtoMessage()               {}
func (*VCUIMUTelemetry) Descriptor() ([]byte, []int) { return fileDescriptor25, []int{1} }

func (m *VCUIMUTelemetry) GetPeriodStartTimestamp() *core.SystemTimestamp {
	if m != nil {
		return m.PeriodStartTimestamp
	}
	return nil
}

func (m *VCUIMUTelemetry) GetPeriodEndTimestamp() *core.SystemTimestamp {
	if m != nil {
		return m.PeriodEndTimestamp
	}
	return nil
}

func (m *VCUIMUTelemetry) GetFrames() []*VCUIMUFrame {
	if m != nil {
		return m.Frames
	}
	return nil
}

func init() {
	proto.RegisterType((*VCUIMUFrame)(nil), "hal.VCUIMUFrame")
	proto.RegisterType((*VCUIMUTelemetry)(nil), "hal.VCUIMUTelemetry")
}

func init() { proto.RegisterFile("packages/hal/proto/vcu_imu_telemetry.proto", fileDescriptor25) }

var fileDescriptor25 = []byte{
	// 285 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x90, 0xb1, 0x4e, 0xeb, 0x30,
	0x14, 0x86, 0x95, 0xe4, 0x36, 0x57, 0x72, 0x06, 0x90, 0x45, 0xc1, 0x62, 0xaa, 0xca, 0x12, 0x31,
	0x24, 0x52, 0x79, 0x04, 0x04, 0x08, 0x21, 0x96, 0xb4, 0x45, 0x6d, 0x17, 0xcb, 0x24, 0x87, 0x26,
	0x22, 0x6e, 0x22, 0xc7, 0x45, 0x75, 0xdf, 0x85, 0x87, 0xe2, 0x8d, 0x50, 0x9c, 0xd4, 0xce, 0xc4,
	0xe8, 0xef, 0xf3, 0x7f, 0x74, 0xce, 0x8f, 0x6e, 0x6b, 0x96, 0x7e, 0xb2, 0x2d, 0x34, 0x71, 0xce,
	0xca, 0xb8, 0x16, 0x95, 0xac, 0xe2, 0xaf, 0x74, 0x4f, 0x0b, 0xbe, 0xa7, 0x12, 0x4a, 0xe0, 0x20,
	0x85, 0x8a, 0x34, 0xc7, 0x5e, 0xce, 0xca, 0xeb, 0x1b, 0x13, 0x48, 0x2b, 0x01, 0x7d, 0x42, 0x16,
	0x1c, 0x1a, 0xc9, 0x78, 0xdd, 0xfd, 0x9c, 0x7e, 0x3b, 0x28, 0x78, 0xbb, 0x5f, 0x3e, 0xbf, 0x2e,
	0x1f, 0x05, 0xe3, 0x80, 0xc7, 0xc8, 0xdf, 0x2a, 0x51, 0xd1, 0x03, 0x71, 0x26, 0x4e, 0xe8, 0x26,
	0xa3, 0xf6, 0xb5, 0x32, 0x58, 0x11, 0xd7, 0xe2, 0xb5, 0xc1, 0x47, 0xe2, 0x59, 0xbc, 0xc1, 0x57,
	0xe8, 0x3f, 0x4b, 0x53, 0x28, 0xe9, 0x81, 0xfc, 0xd3, 0xdc, 0xd7, 0xcf, 0x95, 0x15, 0x8a, 0x8c,
	0x06, 0x62, 0x6d, 0xc5, 0x91, 0xf8, 0x03, 0xb1, 0x99, 0xfe, 0x38, 0xe8, 0xac, 0xdb, 0x6f, 0x71,
	0xba, 0x11, 0xbf, 0xa0, 0xcb, 0x1a, 0x44, 0x51, 0x65, 0xb4, 0x91, 0x4c, 0x48, 0x6a, 0x6e, 0xd2,
	0x3b, 0x07, 0xb3, 0x71, 0xd4, 0x1e, 0x1c, 0xcd, 0x55, 0x23, 0x81, 0x2f, 0x4e, 0x32, 0xb9, 0xe8,
	0x42, 0xf3, 0x36, 0x63, 0x28, 0x7e, 0x42, 0x3d, 0xa7, 0xb0, 0xcb, 0x06, 0xa3, 0xdc, 0xbf, 0x46,
	0xe1, 0x2e, 0xf2, 0xb0, 0xcb, 0xec, 0xa0, 0x10, 0xf9, 0x1f, 0x6d, 0x85, 0x0d, 0xf1, 0x26, 0x5e,
	0x18, 0xcc, 0xce, 0xa3, 0x9c, 0x95, 0xd1, 0xa0, 0xdb, 0xa4, 0xf7, 0xef, 0xbe, 0xae, 0xfe, 0xee,
	0x37, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x67, 0x85, 0x49, 0xd2, 0x01, 0x00, 0x00,
}
