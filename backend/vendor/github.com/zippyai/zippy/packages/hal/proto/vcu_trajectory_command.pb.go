// Code generated by protoc-gen-go. DO NOT EDIT.
// source: packages/hal/proto/vcu_trajectory_command.proto

package hal

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import core "github.com/zippyai/zippy/packages/core/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type VCUArcDriveSegment struct {
	// / Linear velocity along the curve; may be negative.
	// / Units: m/s
	LinearVelocityMetersPerSecond float32 `protobuf:"fixed32,1,opt,name=linearVelocityMetersPerSecond" json:"linearVelocityMetersPerSecond,omitempty"`
	// / Curvature (inverse radius)
	// / Units: m^{-1}
	CurvatureInverseMeters float32 `protobuf:"fixed32,2,opt,name=curvatureInverseMeters" json:"curvatureInverseMeters,omitempty"`
}

func (m *VCUArcDriveSegment) Reset()                    { *m = VCUArcDriveSegment{} }
func (m *VCUArcDriveSegment) String() string            { return proto.CompactTextString(m) }
func (*VCUArcDriveSegment) ProtoMessage()               {}
func (*VCUArcDriveSegment) Descriptor() ([]byte, []int) { return fileDescriptor32, []int{0} }

func (m *VCUArcDriveSegment) GetLinearVelocityMetersPerSecond() float32 {
	if m != nil {
		return m.LinearVelocityMetersPerSecond
	}
	return 0
}

func (m *VCUArcDriveSegment) GetCurvatureInverseMeters() float32 {
	if m != nil {
		return m.CurvatureInverseMeters
	}
	return 0
}

type VCUTurnInPlaceSegment struct {
	// / Rotational velocity; may be negative.
	// / Units: rad/s
	RotationalVelocityRadiansPerSecond float32 `protobuf:"fixed32,1,opt,name=rotationalVelocityRadiansPerSecond" json:"rotationalVelocityRadiansPerSecond,omitempty"`
}

func (m *VCUTurnInPlaceSegment) Reset()                    { *m = VCUTurnInPlaceSegment{} }
func (m *VCUTurnInPlaceSegment) String() string            { return proto.CompactTextString(m) }
func (*VCUTurnInPlaceSegment) ProtoMessage()               {}
func (*VCUTurnInPlaceSegment) Descriptor() ([]byte, []int) { return fileDescriptor32, []int{1} }

func (m *VCUTurnInPlaceSegment) GetRotationalVelocityRadiansPerSecond() float32 {
	if m != nil {
		return m.RotationalVelocityRadiansPerSecond
	}
	return 0
}

// / A trajectory segment.
// /
// / The VCU will make every reasonable attempt to achieve the requested linear velocity
// / upon *entry* of this segment.
type VCUTrajectorySegment struct {
	TargetStartTime *core.SystemTimestamp `protobuf:"bytes,1,opt,name=targetStartTime" json:"targetStartTime,omitempty"`
	// Types that are valid to be assigned to Segment:
	//	*VCUTrajectorySegment_ArcDrive
	//	*VCUTrajectorySegment_TurnInPlace
	Segment isVCUTrajectorySegment_Segment `protobuf_oneof:"segment"`
}

func (m *VCUTrajectorySegment) Reset()                    { *m = VCUTrajectorySegment{} }
func (m *VCUTrajectorySegment) String() string            { return proto.CompactTextString(m) }
func (*VCUTrajectorySegment) ProtoMessage()               {}
func (*VCUTrajectorySegment) Descriptor() ([]byte, []int) { return fileDescriptor32, []int{2} }

type isVCUTrajectorySegment_Segment interface {
	isVCUTrajectorySegment_Segment()
}

type VCUTrajectorySegment_ArcDrive struct {
	ArcDrive *VCUArcDriveSegment `protobuf:"bytes,2,opt,name=arcDrive,oneof"`
}
type VCUTrajectorySegment_TurnInPlace struct {
	TurnInPlace *VCUTurnInPlaceSegment `protobuf:"bytes,3,opt,name=turnInPlace,oneof"`
}

func (*VCUTrajectorySegment_ArcDrive) isVCUTrajectorySegment_Segment()    {}
func (*VCUTrajectorySegment_TurnInPlace) isVCUTrajectorySegment_Segment() {}

func (m *VCUTrajectorySegment) GetSegment() isVCUTrajectorySegment_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *VCUTrajectorySegment) GetTargetStartTime() *core.SystemTimestamp {
	if m != nil {
		return m.TargetStartTime
	}
	return nil
}

func (m *VCUTrajectorySegment) GetArcDrive() *VCUArcDriveSegment {
	if x, ok := m.GetSegment().(*VCUTrajectorySegment_ArcDrive); ok {
		return x.ArcDrive
	}
	return nil
}

func (m *VCUTrajectorySegment) GetTurnInPlace() *VCUTurnInPlaceSegment {
	if x, ok := m.GetSegment().(*VCUTrajectorySegment_TurnInPlace); ok {
		return x.TurnInPlace
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VCUTrajectorySegment) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VCUTrajectorySegment_OneofMarshaler, _VCUTrajectorySegment_OneofUnmarshaler, _VCUTrajectorySegment_OneofSizer, []interface{}{
		(*VCUTrajectorySegment_ArcDrive)(nil),
		(*VCUTrajectorySegment_TurnInPlace)(nil),
	}
}

func _VCUTrajectorySegment_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VCUTrajectorySegment)
	// segment
	switch x := m.Segment.(type) {
	case *VCUTrajectorySegment_ArcDrive:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ArcDrive); err != nil {
			return err
		}
	case *VCUTrajectorySegment_TurnInPlace:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TurnInPlace); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VCUTrajectorySegment.Segment has unexpected type %T", x)
	}
	return nil
}

func _VCUTrajectorySegment_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VCUTrajectorySegment)
	switch tag {
	case 2: // segment.arcDrive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VCUArcDriveSegment)
		err := b.DecodeMessage(msg)
		m.Segment = &VCUTrajectorySegment_ArcDrive{msg}
		return true, err
	case 3: // segment.turnInPlace
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VCUTurnInPlaceSegment)
		err := b.DecodeMessage(msg)
		m.Segment = &VCUTrajectorySegment_TurnInPlace{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VCUTrajectorySegment_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VCUTrajectorySegment)
	// segment
	switch x := m.Segment.(type) {
	case *VCUTrajectorySegment_ArcDrive:
		s := proto.Size(x.ArcDrive)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VCUTrajectorySegment_TurnInPlace:
		s := proto.Size(x.TurnInPlace)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// / A trajectory command. This consists of several trajectory segments. To be considered
// / "safe", the following properties must hold:
// / -# The required acceleration or deceleration required to achieve the initial segment
// /    linear velocity must be "reasonable". Ask Adam what "reasonable" means.
// / -# The required acceleration or deceleration required to move between segments must
// /    be "reasonable". Again, ask Adam what this means.
// / -# The trajectory must terminate with a sequence of segments that decelerates "reasonably"
// /    to a final segment with zero velocity.
// / .
type VCUTrajectoryCommand struct {
	// / Restricted in options file to max_count: 31
	Segments []*VCUTrajectorySegment `protobuf:"bytes,1,rep,name=segments" json:"segments,omitempty"`
}

func (m *VCUTrajectoryCommand) Reset()                    { *m = VCUTrajectoryCommand{} }
func (m *VCUTrajectoryCommand) String() string            { return proto.CompactTextString(m) }
func (*VCUTrajectoryCommand) ProtoMessage()               {}
func (*VCUTrajectoryCommand) Descriptor() ([]byte, []int) { return fileDescriptor32, []int{3} }

func (m *VCUTrajectoryCommand) GetSegments() []*VCUTrajectorySegment {
	if m != nil {
		return m.Segments
	}
	return nil
}

func init() {
	proto.RegisterType((*VCUArcDriveSegment)(nil), "hal.VCUArcDriveSegment")
	proto.RegisterType((*VCUTurnInPlaceSegment)(nil), "hal.VCUTurnInPlaceSegment")
	proto.RegisterType((*VCUTrajectorySegment)(nil), "hal.VCUTrajectorySegment")
	proto.RegisterType((*VCUTrajectoryCommand)(nil), "hal.VCUTrajectoryCommand")
}

func init() { proto.RegisterFile("packages/hal/proto/vcu_trajectory_command.proto", fileDescriptor32) }

var fileDescriptor32 = []byte{
	// 347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xcb, 0x4e, 0xfa, 0x50,
	0x10, 0x87, 0x29, 0x24, 0xff, 0xcb, 0xe9, 0xc2, 0xa4, 0x11, 0xad, 0x24, 0x26, 0xa4, 0x6e, 0x58,
	0xb5, 0x09, 0x46, 0x97, 0x1a, 0x85, 0x05, 0x2c, 0x30, 0xa4, 0x05, 0xb6, 0x64, 0x3c, 0x4c, 0x4a,
	0xb5, 0x3d, 0x87, 0x4c, 0xa7, 0x4d, 0x78, 0x0d, 0xdf, 0xce, 0xb7, 0x31, 0xb4, 0xb4, 0x1a, 0x88,
	0xc6, 0xf5, 0x7c, 0xbf, 0xb9, 0x7c, 0x19, 0xe1, 0x6d, 0x40, 0xbe, 0x42, 0x88, 0xa9, 0xb7, 0x86,
	0xd8, 0xdb, 0x90, 0x66, 0xed, 0xe5, 0x32, 0x5b, 0x32, 0xc1, 0x0b, 0x4a, 0xd6, 0xb4, 0x5d, 0x4a,
	0x9d, 0x24, 0xa0, 0x56, 0x6e, 0x51, 0xb4, 0x5a, 0x6b, 0x88, 0x3b, 0x57, 0x75, 0x4a, 0x6a, 0xc2,
	0x7d, 0x8c, 0xa3, 0x04, 0x53, 0x86, 0x64, 0x53, 0x92, 0xce, 0x9b, 0x21, 0xac, 0xc5, 0x60, 0xfe,
	0x40, 0x72, 0x48, 0x51, 0x8e, 0x01, 0x86, 0x09, 0x2a, 0xb6, 0x86, 0xe2, 0x32, 0x8e, 0x14, 0x02,
	0x2d, 0x30, 0xd6, 0x32, 0xe2, 0xed, 0x04, 0x19, 0x29, 0x9d, 0x22, 0x05, 0x28, 0xb5, 0x5a, 0xd9,
	0x46, 0xd7, 0xe8, 0x35, 0xfd, 0x9f, 0x21, 0xeb, 0x56, 0x9c, 0xc9, 0x8c, 0x72, 0xe0, 0x8c, 0x70,
	0xac, 0x72, 0xa4, 0x14, 0x4b, 0xc4, 0x6e, 0x16, 0xf1, 0x6f, 0xaa, 0x4e, 0x28, 0xda, 0x8b, 0xc1,
	0x7c, 0x96, 0x91, 0x1a, 0xab, 0x69, 0x0c, 0xb2, 0x5e, 0xeb, 0x49, 0x38, 0xa4, 0x19, 0x38, 0xd2,
	0x0a, 0xe2, 0x6a, 0xaa, 0x0f, 0xab, 0x08, 0xd4, 0xd1, 0x6e, 0xbf, 0x20, 0x9d, 0x77, 0x43, 0x9c,
	0xee, 0x26, 0xd5, 0x1e, 0xab, 0x41, 0xf7, 0xe2, 0x84, 0x81, 0x42, 0xe4, 0x80, 0x81, 0x78, 0x16,
	0x25, 0x58, 0x74, 0x35, 0xfb, 0x6d, 0x77, 0x27, 0xd3, 0x0d, 0xb6, 0x29, 0x63, 0x32, 0xab, 0x64,
	0xfa, 0x87, 0xb4, 0x75, 0x23, 0xfe, 0xc1, 0xde, 0x69, 0x71, 0xac, 0xd9, 0x3f, 0x77, 0xd7, 0x10,
	0xbb, 0xc7, 0xae, 0x47, 0x0d, 0xbf, 0x46, 0xad, 0x3b, 0x61, 0xf2, 0xe7, 0xd9, 0x76, 0xab, 0x48,
	0x76, 0xaa, 0xe4, 0xb1, 0x91, 0x51, 0xc3, 0xff, 0x1a, 0x78, 0xfc, 0x2f, 0xfe, 0xa6, 0x65, 0xc5,
	0x99, 0x1c, 0x9c, 0x36, 0x28, 0x3f, 0x64, 0xb7, 0xd9, 0x1e, 0x49, 0x6d, 0xa3, 0xdb, 0xea, 0x99,
	0xfd, 0x8b, 0xba, 0xff, 0xa1, 0x07, 0xbf, 0x46, 0x9f, 0xff, 0x14, 0xff, 0x72, 0xfd, 0x11, 0x00,
	0x00, 0xff, 0xff, 0xc3, 0xc1, 0xe4, 0x4d, 0x8c, 0x02, 0x00, 0x00,
}
