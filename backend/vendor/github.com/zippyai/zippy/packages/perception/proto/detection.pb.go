// Code generated by protoc-gen-go. DO NOT EDIT.
// source: packages/perception/proto/detection.proto

/*
Package perception is a generated protocol buffer package.

It is generated from these files:
	packages/perception/proto/detection.proto

It has these top-level messages:
	Category
	Motion
	DeviceMetadata
	CameraDeviceMetadata
	ObjectBoundingBox
	Object3DBoundingBox
	Object3DConvexHull
	CameraAlignedBoxDetection
	CameraAligned3DBoxDetection
	ObjectSematicMask
	CameraPixelsDetection
	Detection
*/
package perception

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import core "github.com/zippyai/zippy/packages/core/proto"
import hal "github.com/zippyai/zippy/packages/hal/proto"
import calibration1 "github.com/zippyai/zippy/packages/calibration/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Category_CategoryType int32

const (
	Category_UNKNOWN   Category_CategoryType = 0
	Category_ANIMAL    Category_CategoryType = 10
	Category_PERSON    Category_CategoryType = 20
	Category_BICYCLE   Category_CategoryType = 30
	Category_MOTORBIKE Category_CategoryType = 40
	Category_CAR       Category_CategoryType = 50
	Category_BUS       Category_CategoryType = 60
	Category_TRUCK     Category_CategoryType = 70
)

var Category_CategoryType_name = map[int32]string{
	0:  "UNKNOWN",
	10: "ANIMAL",
	20: "PERSON",
	30: "BICYCLE",
	40: "MOTORBIKE",
	50: "CAR",
	60: "BUS",
	70: "TRUCK",
}
var Category_CategoryType_value = map[string]int32{
	"UNKNOWN":   0,
	"ANIMAL":    10,
	"PERSON":    20,
	"BICYCLE":   30,
	"MOTORBIKE": 40,
	"CAR":       50,
	"BUS":       60,
	"TRUCK":     70,
}

func (x Category_CategoryType) String() string {
	return proto.EnumName(Category_CategoryType_name, int32(x))
}
func (Category_CategoryType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Motion_MotionType int32

const (
	Motion_UNKNOWN    Motion_MotionType = 0
	Motion_MOVING     Motion_MotionType = 10
	Motion_STATIONARY Motion_MotionType = 20
)

var Motion_MotionType_name = map[int32]string{
	0:  "UNKNOWN",
	10: "MOVING",
	20: "STATIONARY",
}
var Motion_MotionType_value = map[string]int32{
	"UNKNOWN":    0,
	"MOVING":     10,
	"STATIONARY": 20,
}

func (x Motion_MotionType) String() string {
	return proto.EnumName(Motion_MotionType_name, int32(x))
}
func (Motion_MotionType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

// A minimal set of categories. Enumerations are wrapped to allow for duplicate
// names, given protobuf's scoping rules.
type Category struct {
	Type       Category_CategoryType `protobuf:"varint,1,opt,name=type,enum=perception.Category_CategoryType" json:"type,omitempty"`
	Confidence float64               `protobuf:"fixed64,2,opt,name=confidence" json:"confidence,omitempty"`
}

func (m *Category) Reset()                    { *m = Category{} }
func (m *Category) String() string            { return proto.CompactTextString(m) }
func (*Category) ProtoMessage()               {}
func (*Category) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Category) GetType() Category_CategoryType {
	if m != nil {
		return m.Type
	}
	return Category_UNKNOWN
}

func (m *Category) GetConfidence() float64 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

// Velocity attributes
type Motion struct {
	Type       Motion_MotionType `protobuf:"varint,1,opt,name=type,enum=perception.Motion_MotionType" json:"type,omitempty"`
	Confidence float64           `protobuf:"fixed64,2,opt,name=confidence" json:"confidence,omitempty"`
}

func (m *Motion) Reset()                    { *m = Motion{} }
func (m *Motion) String() string            { return proto.CompactTextString(m) }
func (*Motion) ProtoMessage()               {}
func (*Motion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Motion) GetType() Motion_MotionType {
	if m != nil {
		return m.Type
	}
	return Motion_UNKNOWN
}

func (m *Motion) GetConfidence() float64 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

// Capturing the metadata of the sensor performing the detection process.
type DeviceMetadata struct {
	Device     *hal.Device           `protobuf:"bytes,1,opt,name=device" json:"device,omitempty"`
	SensorTime *core.SystemTimestamp `protobuf:"bytes,2,opt,name=sensor_time,json=sensorTime" json:"sensor_time,omitempty"`
}

func (m *DeviceMetadata) Reset()                    { *m = DeviceMetadata{} }
func (m *DeviceMetadata) String() string            { return proto.CompactTextString(m) }
func (*DeviceMetadata) ProtoMessage()               {}
func (*DeviceMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DeviceMetadata) GetDevice() *hal.Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *DeviceMetadata) GetSensorTime() *core.SystemTimestamp {
	if m != nil {
		return m.SensorTime
	}
	return nil
}

// Capturing the metadata of the sensor performing the detection process.
type CameraDeviceMetadata struct {
	DeviceMetadata    *DeviceMetadata `protobuf:"bytes,1,opt,name=device_metadata,json=deviceMetadata" json:"device_metadata,omitempty"`
	ImageWidthPixels  uint32          `protobuf:"varint,2,opt,name=image_width_pixels,json=imageWidthPixels" json:"image_width_pixels,omitempty"`
	ImageHeightPixels uint32          `protobuf:"varint,3,opt,name=image_height_pixels,json=imageHeightPixels" json:"image_height_pixels,omitempty"`
}

func (m *CameraDeviceMetadata) Reset()                    { *m = CameraDeviceMetadata{} }
func (m *CameraDeviceMetadata) String() string            { return proto.CompactTextString(m) }
func (*CameraDeviceMetadata) ProtoMessage()               {}
func (*CameraDeviceMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CameraDeviceMetadata) GetDeviceMetadata() *DeviceMetadata {
	if m != nil {
		return m.DeviceMetadata
	}
	return nil
}

func (m *CameraDeviceMetadata) GetImageWidthPixels() uint32 {
	if m != nil {
		return m.ImageWidthPixels
	}
	return 0
}

func (m *CameraDeviceMetadata) GetImageHeightPixels() uint32 {
	if m != nil {
		return m.ImageHeightPixels
	}
	return 0
}

// Each detection has a bounding box, an associated category, and motion attribute
// (these may be unknown). A confidence score *should* be provided for each category and
// attribute, but is not strictly required.
//
// The most basic type of detection - an aligned box in the camera frame. It is
// parameterized by the minimum X and Y coordinates (in the camera coordinate
// system) and the box extents. For example, if:
//
// top_left_y = Y'
// top_left_x = X'
// extents_x = X*
// extents_y = Y*
//
// Then the detection resembles the following:
//
//           X'
//     +-----------------> X
//     |     ^
//     |     |
//  Y' <-----+-------+ ^
//     |     |       | |
//     |     |       | |
//     |     |       | Y*
//     |     |       | |
//     |     +-------+ v
//     v     <---X*-->
//     Y
type ObjectBoundingBox struct {
	Category *Category `protobuf:"bytes,1,opt,name=category" json:"category,omitempty"`
	Motion   *Motion   `protobuf:"bytes,2,opt,name=motion" json:"motion,omitempty"`
	TopLeftX float64   `protobuf:"fixed64,3,opt,name=top_left_x,json=topLeftX" json:"top_left_x,omitempty"`
	TopLeftY float64   `protobuf:"fixed64,4,opt,name=top_left_y,json=topLeftY" json:"top_left_y,omitempty"`
	ExtentsX float64   `protobuf:"fixed64,5,opt,name=extents_x,json=extentsX" json:"extents_x,omitempty"`
	ExtentsY float64   `protobuf:"fixed64,6,opt,name=extents_y,json=extentsY" json:"extents_y,omitempty"`
	// Information coming from tracking
	InstanceId uint32 `protobuf:"varint,51,opt,name=instance_id,json=instanceId" json:"instance_id,omitempty"`
}

func (m *ObjectBoundingBox) Reset()                    { *m = ObjectBoundingBox{} }
func (m *ObjectBoundingBox) String() string            { return proto.CompactTextString(m) }
func (*ObjectBoundingBox) ProtoMessage()               {}
func (*ObjectBoundingBox) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ObjectBoundingBox) GetCategory() *Category {
	if m != nil {
		return m.Category
	}
	return nil
}

func (m *ObjectBoundingBox) GetMotion() *Motion {
	if m != nil {
		return m.Motion
	}
	return nil
}

func (m *ObjectBoundingBox) GetTopLeftX() float64 {
	if m != nil {
		return m.TopLeftX
	}
	return 0
}

func (m *ObjectBoundingBox) GetTopLeftY() float64 {
	if m != nil {
		return m.TopLeftY
	}
	return 0
}

func (m *ObjectBoundingBox) GetExtentsX() float64 {
	if m != nil {
		return m.ExtentsX
	}
	return 0
}

func (m *ObjectBoundingBox) GetExtentsY() float64 {
	if m != nil {
		return m.ExtentsY
	}
	return 0
}

func (m *ObjectBoundingBox) GetInstanceId() uint32 {
	if m != nil {
		return m.InstanceId
	}
	return 0
}

// Each detection has a 3d bounding box, an associated category, and motion attribute
// (these may be unknown). A confidence score *should* be provided for each category and
// attribute, but is not strictly required.
// The coordinate system describing the 3D bounding box should be encoded in the "pose" field.
// Optionally, the uncertainty on 3D estimation can be encoded.
type Object3DBoundingBox struct {
	Category *Category                              `protobuf:"bytes,1,opt,name=category" json:"category,omitempty"`
	Motion   *Motion                                `protobuf:"bytes,2,opt,name=motion" json:"motion,omitempty"`
	Pose     *calibration1.CoordinateTransformation `protobuf:"bytes,3,opt,name=pose" json:"pose,omitempty"`
	ExtentsX float64                                `protobuf:"fixed64,4,opt,name=extents_x,json=extentsX" json:"extents_x,omitempty"`
	ExtentsY float64                                `protobuf:"fixed64,5,opt,name=extents_y,json=extentsY" json:"extents_y,omitempty"`
	ExtentsZ float64                                `protobuf:"fixed64,6,opt,name=extents_z,json=extentsZ" json:"extents_z,omitempty"`
	// Information coming from tracking
	InstanceId uint32 `protobuf:"varint,51,opt,name=instance_id,json=instanceId" json:"instance_id,omitempty"`
	// optional, encoding extra uncertainty while estimating 3d properties
	UncertaintyPositionX float64 `protobuf:"fixed64,7,opt,name=uncertainty_position_x,json=uncertaintyPositionX" json:"uncertainty_position_x,omitempty"`
	UncertaintyPositionY float64 `protobuf:"fixed64,8,opt,name=uncertainty_position_y,json=uncertaintyPositionY" json:"uncertainty_position_y,omitempty"`
	UncertaintyPositionZ float64 `protobuf:"fixed64,9,opt,name=uncertainty_position_z,json=uncertaintyPositionZ" json:"uncertainty_position_z,omitempty"`
	UncertaintyRotationX float64 `protobuf:"fixed64,10,opt,name=uncertainty_rotation_x,json=uncertaintyRotationX" json:"uncertainty_rotation_x,omitempty"`
	UncertaintyRotationY float64 `protobuf:"fixed64,11,opt,name=uncertainty_rotation_y,json=uncertaintyRotationY" json:"uncertainty_rotation_y,omitempty"`
	UncertaintyRotationZ float64 `protobuf:"fixed64,12,opt,name=uncertainty_rotation_z,json=uncertaintyRotationZ" json:"uncertainty_rotation_z,omitempty"`
	UncertaintyExtentsX  float64 `protobuf:"fixed64,13,opt,name=uncertainty_extents_x,json=uncertaintyExtentsX" json:"uncertainty_extents_x,omitempty"`
	UncertaintyExtentsY  float64 `protobuf:"fixed64,14,opt,name=uncertainty_extents_y,json=uncertaintyExtentsY" json:"uncertainty_extents_y,omitempty"`
	UncertaintyExtentsZ  float64 `protobuf:"fixed64,15,opt,name=uncertainty_extents_z,json=uncertaintyExtentsZ" json:"uncertainty_extents_z,omitempty"`
}

func (m *Object3DBoundingBox) Reset()                    { *m = Object3DBoundingBox{} }
func (m *Object3DBoundingBox) String() string            { return proto.CompactTextString(m) }
func (*Object3DBoundingBox) ProtoMessage()               {}
func (*Object3DBoundingBox) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Object3DBoundingBox) GetCategory() *Category {
	if m != nil {
		return m.Category
	}
	return nil
}

func (m *Object3DBoundingBox) GetMotion() *Motion {
	if m != nil {
		return m.Motion
	}
	return nil
}

func (m *Object3DBoundingBox) GetPose() *calibration1.CoordinateTransformation {
	if m != nil {
		return m.Pose
	}
	return nil
}

func (m *Object3DBoundingBox) GetExtentsX() float64 {
	if m != nil {
		return m.ExtentsX
	}
	return 0
}

func (m *Object3DBoundingBox) GetExtentsY() float64 {
	if m != nil {
		return m.ExtentsY
	}
	return 0
}

func (m *Object3DBoundingBox) GetExtentsZ() float64 {
	if m != nil {
		return m.ExtentsZ
	}
	return 0
}

func (m *Object3DBoundingBox) GetInstanceId() uint32 {
	if m != nil {
		return m.InstanceId
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyPositionX() float64 {
	if m != nil {
		return m.UncertaintyPositionX
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyPositionY() float64 {
	if m != nil {
		return m.UncertaintyPositionY
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyPositionZ() float64 {
	if m != nil {
		return m.UncertaintyPositionZ
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyRotationX() float64 {
	if m != nil {
		return m.UncertaintyRotationX
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyRotationY() float64 {
	if m != nil {
		return m.UncertaintyRotationY
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyRotationZ() float64 {
	if m != nil {
		return m.UncertaintyRotationZ
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyExtentsX() float64 {
	if m != nil {
		return m.UncertaintyExtentsX
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyExtentsY() float64 {
	if m != nil {
		return m.UncertaintyExtentsY
	}
	return 0
}

func (m *Object3DBoundingBox) GetUncertaintyExtentsZ() float64 {
	if m != nil {
		return m.UncertaintyExtentsZ
	}
	return 0
}

// Each detection has a 3d convex hull, an associated category, and motion attribute
// (these may be unknown). A confidence score *should* be provided for each category and
// attribute, but is not strictly required.
// The coordinate system describing the 3D bounding box should be encoded in the "pose" field.
// Optionally, the uncertainty on 3D estimation can be encoded.
type Object3DConvexHull struct {
	Category *Category                              `protobuf:"bytes,1,opt,name=category" json:"category,omitempty"`
	Motion   *Motion                                `protobuf:"bytes,2,opt,name=motion" json:"motion,omitempty"`
	Pose     *calibration1.CoordinateTransformation `protobuf:"bytes,3,opt,name=pose" json:"pose,omitempty"`
	Xs       []float64                              `protobuf:"fixed64,4,rep,packed,name=xs" json:"xs,omitempty"`
	ExtentsY float64                                `protobuf:"fixed64,5,opt,name=extents_y,json=extentsY" json:"extents_y,omitempty"`
	Zs       []float64                              `protobuf:"fixed64,6,rep,packed,name=zs" json:"zs,omitempty"`
	// Information coming from tracking
	InstanceId uint32 `protobuf:"varint,51,opt,name=instance_id,json=instanceId" json:"instance_id,omitempty"`
	// optional, encoding extra uncertainty while estimating 3d properties
	UncertaintyPositionX float64 `protobuf:"fixed64,7,opt,name=uncertainty_position_x,json=uncertaintyPositionX" json:"uncertainty_position_x,omitempty"`
	UncertaintyPositionY float64 `protobuf:"fixed64,8,opt,name=uncertainty_position_y,json=uncertaintyPositionY" json:"uncertainty_position_y,omitempty"`
	UncertaintyPositionZ float64 `protobuf:"fixed64,9,opt,name=uncertainty_position_z,json=uncertaintyPositionZ" json:"uncertainty_position_z,omitempty"`
	UncertaintyRotationX float64 `protobuf:"fixed64,10,opt,name=uncertainty_rotation_x,json=uncertaintyRotationX" json:"uncertainty_rotation_x,omitempty"`
	UncertaintyRotationY float64 `protobuf:"fixed64,11,opt,name=uncertainty_rotation_y,json=uncertaintyRotationY" json:"uncertainty_rotation_y,omitempty"`
	UncertaintyRotationZ float64 `protobuf:"fixed64,12,opt,name=uncertainty_rotation_z,json=uncertaintyRotationZ" json:"uncertainty_rotation_z,omitempty"`
	UncertaintyExtentsY  float64 `protobuf:"fixed64,14,opt,name=uncertainty_extents_y,json=uncertaintyExtentsY" json:"uncertainty_extents_y,omitempty"`
}

func (m *Object3DConvexHull) Reset()                    { *m = Object3DConvexHull{} }
func (m *Object3DConvexHull) String() string            { return proto.CompactTextString(m) }
func (*Object3DConvexHull) ProtoMessage()               {}
func (*Object3DConvexHull) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Object3DConvexHull) GetCategory() *Category {
	if m != nil {
		return m.Category
	}
	return nil
}

func (m *Object3DConvexHull) GetMotion() *Motion {
	if m != nil {
		return m.Motion
	}
	return nil
}

func (m *Object3DConvexHull) GetPose() *calibration1.CoordinateTransformation {
	if m != nil {
		return m.Pose
	}
	return nil
}

func (m *Object3DConvexHull) GetXs() []float64 {
	if m != nil {
		return m.Xs
	}
	return nil
}

func (m *Object3DConvexHull) GetExtentsY() float64 {
	if m != nil {
		return m.ExtentsY
	}
	return 0
}

func (m *Object3DConvexHull) GetZs() []float64 {
	if m != nil {
		return m.Zs
	}
	return nil
}

func (m *Object3DConvexHull) GetInstanceId() uint32 {
	if m != nil {
		return m.InstanceId
	}
	return 0
}

func (m *Object3DConvexHull) GetUncertaintyPositionX() float64 {
	if m != nil {
		return m.UncertaintyPositionX
	}
	return 0
}

func (m *Object3DConvexHull) GetUncertaintyPositionY() float64 {
	if m != nil {
		return m.UncertaintyPositionY
	}
	return 0
}

func (m *Object3DConvexHull) GetUncertaintyPositionZ() float64 {
	if m != nil {
		return m.UncertaintyPositionZ
	}
	return 0
}

func (m *Object3DConvexHull) GetUncertaintyRotationX() float64 {
	if m != nil {
		return m.UncertaintyRotationX
	}
	return 0
}

func (m *Object3DConvexHull) GetUncertaintyRotationY() float64 {
	if m != nil {
		return m.UncertaintyRotationY
	}
	return 0
}

func (m *Object3DConvexHull) GetUncertaintyRotationZ() float64 {
	if m != nil {
		return m.UncertaintyRotationZ
	}
	return 0
}

func (m *Object3DConvexHull) GetUncertaintyExtentsY() float64 {
	if m != nil {
		return m.UncertaintyExtentsY
	}
	return 0
}

// Describing the detection results as bounding boxes,
// containing image's metadata, detected system-timestamp, and a series of bounding boxes
type CameraAlignedBoxDetection struct {
	CameraDeviceMetadata *CameraDeviceMetadata `protobuf:"bytes,1,opt,name=camera_device_metadata,json=cameraDeviceMetadata" json:"camera_device_metadata,omitempty"`
	SystemTime           *core.SystemTimestamp `protobuf:"bytes,2,opt,name=system_time,json=systemTime" json:"system_time,omitempty"`
	BoundingBoxes        []*ObjectBoundingBox  `protobuf:"bytes,3,rep,name=bounding_boxes,json=boundingBoxes" json:"bounding_boxes,omitempty"`
}

func (m *CameraAlignedBoxDetection) Reset()                    { *m = CameraAlignedBoxDetection{} }
func (m *CameraAlignedBoxDetection) String() string            { return proto.CompactTextString(m) }
func (*CameraAlignedBoxDetection) ProtoMessage()               {}
func (*CameraAlignedBoxDetection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CameraAlignedBoxDetection) GetCameraDeviceMetadata() *CameraDeviceMetadata {
	if m != nil {
		return m.CameraDeviceMetadata
	}
	return nil
}

func (m *CameraAlignedBoxDetection) GetSystemTime() *core.SystemTimestamp {
	if m != nil {
		return m.SystemTime
	}
	return nil
}

func (m *CameraAlignedBoxDetection) GetBoundingBoxes() []*ObjectBoundingBox {
	if m != nil {
		return m.BoundingBoxes
	}
	return nil
}

// Describing the detection results as three-dimensional bounding boxes,
// containing image's metadata, detected system-timestamp, and a series of 3d bounding boxes
type CameraAligned3DBoxDetection struct {
	CameraDeviceMetadata *CameraDeviceMetadata  `protobuf:"bytes,1,opt,name=camera_device_metadata,json=cameraDeviceMetadata" json:"camera_device_metadata,omitempty"`
	SystemTime           *core.SystemTimestamp  `protobuf:"bytes,2,opt,name=system_time,json=systemTime" json:"system_time,omitempty"`
	BoundingBoxes        []*Object3DBoundingBox `protobuf:"bytes,3,rep,name=bounding_boxes,json=boundingBoxes" json:"bounding_boxes,omitempty"`
	ConvexHulls          []*Object3DConvexHull  `protobuf:"bytes,4,rep,name=convex_hulls,json=convexHulls" json:"convex_hulls,omitempty"`
}

func (m *CameraAligned3DBoxDetection) Reset()                    { *m = CameraAligned3DBoxDetection{} }
func (m *CameraAligned3DBoxDetection) String() string            { return proto.CompactTextString(m) }
func (*CameraAligned3DBoxDetection) ProtoMessage()               {}
func (*CameraAligned3DBoxDetection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CameraAligned3DBoxDetection) GetCameraDeviceMetadata() *CameraDeviceMetadata {
	if m != nil {
		return m.CameraDeviceMetadata
	}
	return nil
}

func (m *CameraAligned3DBoxDetection) GetSystemTime() *core.SystemTimestamp {
	if m != nil {
		return m.SystemTime
	}
	return nil
}

func (m *CameraAligned3DBoxDetection) GetBoundingBoxes() []*Object3DBoundingBox {
	if m != nil {
		return m.BoundingBoxes
	}
	return nil
}

func (m *CameraAligned3DBoxDetection) GetConvexHulls() []*Object3DConvexHull {
	if m != nil {
		return m.ConvexHulls
	}
	return nil
}

// Each detection has a semantic pixel-wise-mask, an associated category, and motion attribute
// (these may be unknown). A confidence score *should* be provided for each category and
// attribute, but is not strictly required.
//
// XY pixel indices of an image corresponding to a detection in row-major
// order. For example, for example indices 0 <= {a0, ..., z0, a1, ...} <
// MAX_XY_INDEX, this detection resembles the following:
//
//   +-----------------> X
//   |
//   |     a0b0c0d0e0f0g0
//   |     h0i0j0k0l0m0n0
//   |     o0p0q0r0s0t0
//   |     u0v0w0x0y0
//   |     z0a1b1c1
//   |     d1e1f1
//   v
//   Y
type ObjectSematicMask struct {
	Category       *Category `protobuf:"bytes,1,opt,name=category" json:"category,omitempty"`
	Motion         *Motion   `protobuf:"bytes,2,opt,name=motion" json:"motion,omitempty"`
	PixelXyIndices []uint32  `protobuf:"varint,3,rep,packed,name=pixel_xy_indices,json=pixelXyIndices" json:"pixel_xy_indices,omitempty"`
}

func (m *ObjectSematicMask) Reset()                    { *m = ObjectSematicMask{} }
func (m *ObjectSematicMask) String() string            { return proto.CompactTextString(m) }
func (*ObjectSematicMask) ProtoMessage()               {}
func (*ObjectSematicMask) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ObjectSematicMask) GetCategory() *Category {
	if m != nil {
		return m.Category
	}
	return nil
}

func (m *ObjectSematicMask) GetMotion() *Motion {
	if m != nil {
		return m.Motion
	}
	return nil
}

func (m *ObjectSematicMask) GetPixelXyIndices() []uint32 {
	if m != nil {
		return m.PixelXyIndices
	}
	return nil
}

// Describing the detection results as pixel-wise masks,
// contatining image's metadata, detected system-timestamp, and a series of masks
type CameraPixelsDetection struct {
	CameraDeviceMetadata *CameraDeviceMetadata `protobuf:"bytes,1,opt,name=camera_device_metadata,json=cameraDeviceMetadata" json:"camera_device_metadata,omitempty"`
	SystemTime           *core.SystemTimestamp `protobuf:"bytes,2,opt,name=system_time,json=systemTime" json:"system_time,omitempty"`
	Masks                []*ObjectSematicMask  `protobuf:"bytes,3,rep,name=masks" json:"masks,omitempty"`
}

func (m *CameraPixelsDetection) Reset()                    { *m = CameraPixelsDetection{} }
func (m *CameraPixelsDetection) String() string            { return proto.CompactTextString(m) }
func (*CameraPixelsDetection) ProtoMessage()               {}
func (*CameraPixelsDetection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CameraPixelsDetection) GetCameraDeviceMetadata() *CameraDeviceMetadata {
	if m != nil {
		return m.CameraDeviceMetadata
	}
	return nil
}

func (m *CameraPixelsDetection) GetSystemTime() *core.SystemTimestamp {
	if m != nil {
		return m.SystemTime
	}
	return nil
}

func (m *CameraPixelsDetection) GetMasks() []*ObjectSematicMask {
	if m != nil {
		return m.Masks
	}
	return nil
}

type Detection struct {
	// Types that are valid to be assigned to Detection:
	//	*Detection_BoxDetection
	//	*Detection_Box_3DDetection
	//	*Detection_PixelsDetection
	Detection isDetection_Detection `protobuf_oneof:"detection"`
}

func (m *Detection) Reset()                    { *m = Detection{} }
func (m *Detection) String() string            { return proto.CompactTextString(m) }
func (*Detection) ProtoMessage()               {}
func (*Detection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isDetection_Detection interface {
	isDetection_Detection()
}

type Detection_BoxDetection struct {
	BoxDetection *CameraAlignedBoxDetection `protobuf:"bytes,1,opt,name=box_detection,json=boxDetection,oneof"`
}
type Detection_Box_3DDetection struct {
	Box_3DDetection *CameraAligned3DBoxDetection `protobuf:"bytes,2,opt,name=box_3d_detection,json=box3dDetection,oneof"`
}
type Detection_PixelsDetection struct {
	PixelsDetection *CameraPixelsDetection `protobuf:"bytes,3,opt,name=pixels_detection,json=pixelsDetection,oneof"`
}

func (*Detection_BoxDetection) isDetection_Detection()    {}
func (*Detection_Box_3DDetection) isDetection_Detection() {}
func (*Detection_PixelsDetection) isDetection_Detection() {}

func (m *Detection) GetDetection() isDetection_Detection {
	if m != nil {
		return m.Detection
	}
	return nil
}

func (m *Detection) GetBoxDetection() *CameraAlignedBoxDetection {
	if x, ok := m.GetDetection().(*Detection_BoxDetection); ok {
		return x.BoxDetection
	}
	return nil
}

func (m *Detection) GetBox_3DDetection() *CameraAligned3DBoxDetection {
	if x, ok := m.GetDetection().(*Detection_Box_3DDetection); ok {
		return x.Box_3DDetection
	}
	return nil
}

func (m *Detection) GetPixelsDetection() *CameraPixelsDetection {
	if x, ok := m.GetDetection().(*Detection_PixelsDetection); ok {
		return x.PixelsDetection
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Detection) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Detection_OneofMarshaler, _Detection_OneofUnmarshaler, _Detection_OneofSizer, []interface{}{
		(*Detection_BoxDetection)(nil),
		(*Detection_Box_3DDetection)(nil),
		(*Detection_PixelsDetection)(nil),
	}
}

func _Detection_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Detection)
	// detection
	switch x := m.Detection.(type) {
	case *Detection_BoxDetection:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BoxDetection); err != nil {
			return err
		}
	case *Detection_Box_3DDetection:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Box_3DDetection); err != nil {
			return err
		}
	case *Detection_PixelsDetection:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PixelsDetection); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Detection.Detection has unexpected type %T", x)
	}
	return nil
}

func _Detection_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Detection)
	switch tag {
	case 1: // detection.box_detection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CameraAlignedBoxDetection)
		err := b.DecodeMessage(msg)
		m.Detection = &Detection_BoxDetection{msg}
		return true, err
	case 2: // detection.box_3d_detection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CameraAligned3DBoxDetection)
		err := b.DecodeMessage(msg)
		m.Detection = &Detection_Box_3DDetection{msg}
		return true, err
	case 3: // detection.pixels_detection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CameraPixelsDetection)
		err := b.DecodeMessage(msg)
		m.Detection = &Detection_PixelsDetection{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Detection_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Detection)
	// detection
	switch x := m.Detection.(type) {
	case *Detection_BoxDetection:
		s := proto.Size(x.BoxDetection)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_Box_3DDetection:
		s := proto.Size(x.Box_3DDetection)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_PixelsDetection:
		s := proto.Size(x.PixelsDetection)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Category)(nil), "perception.Category")
	proto.RegisterType((*Motion)(nil), "perception.Motion")
	proto.RegisterType((*DeviceMetadata)(nil), "perception.DeviceMetadata")
	proto.RegisterType((*CameraDeviceMetadata)(nil), "perception.CameraDeviceMetadata")
	proto.RegisterType((*ObjectBoundingBox)(nil), "perception.ObjectBoundingBox")
	proto.RegisterType((*Object3DBoundingBox)(nil), "perception.Object3dBoundingBox")
	proto.RegisterType((*Object3DConvexHull)(nil), "perception.Object3dConvexHull")
	proto.RegisterType((*CameraAlignedBoxDetection)(nil), "perception.CameraAlignedBoxDetection")
	proto.RegisterType((*CameraAligned3DBoxDetection)(nil), "perception.CameraAligned3dBoxDetection")
	proto.RegisterType((*ObjectSematicMask)(nil), "perception.ObjectSematicMask")
	proto.RegisterType((*CameraPixelsDetection)(nil), "perception.CameraPixelsDetection")
	proto.RegisterType((*Detection)(nil), "perception.Detection")
	proto.RegisterEnum("perception.Category_CategoryType", Category_CategoryType_name, Category_CategoryType_value)
	proto.RegisterEnum("perception.Motion_MotionType", Motion_MotionType_name, Motion_MotionType_value)
}

func init() { proto.RegisterFile("packages/perception/proto/detection.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1106 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x5f, 0x6f, 0xdb, 0x54,
	0x14, 0x9f, 0xd3, 0x36, 0x6b, 0x8e, 0x9b, 0xcc, 0xbb, 0xcb, 0x26, 0xd3, 0x41, 0xdb, 0x79, 0x9a,
	0x08, 0x08, 0xa5, 0x90, 0x30, 0x24, 0x10, 0x2f, 0x49, 0xda, 0xd1, 0xa8, 0x4d, 0x52, 0xdd, 0xa4,
	0x5b, 0xd3, 0x17, 0xcb, 0xb1, 0x6f, 0x13, 0xd3, 0xc4, 0xd7, 0xb2, 0x6f, 0x87, 0x9d, 0x57, 0x24,
	0x84, 0xc4, 0x1b, 0xaf, 0x7c, 0x11, 0xf8, 0x14, 0x7c, 0x01, 0xbe, 0x04, 0xdf, 0x00, 0xf9, 0xda,
	0x49, 0xec, 0xa4, 0x2e, 0xf0, 0x00, 0xf4, 0x81, 0xa7, 0xd8, 0xe7, 0xfc, 0x7e, 0xc7, 0xe7, 0xdf,
	0xbd, 0xe7, 0x04, 0x3e, 0xb0, 0x35, 0xfd, 0x4a, 0x1b, 0x12, 0x77, 0xdf, 0x26, 0x8e, 0x4e, 0x6c,
	0x66, 0x52, 0x6b, 0xdf, 0x76, 0x28, 0xa3, 0xfb, 0x06, 0x61, 0x44, 0x0f, 0xde, 0xcb, 0xfc, 0x1d,
	0xc1, 0x02, 0xb1, 0xfd, 0x7c, 0x4e, 0xd3, 0xa9, 0x43, 0x22, 0x02, 0x33, 0x27, 0xc4, 0x65, 0xda,
	0xc4, 0x0e, 0x09, 0xdb, 0xbb, 0x73, 0xd0, 0x48, 0x1b, 0xcf, 0x8d, 0xbe, 0x35, 0x75, 0x12, 0x01,
	0xbe, 0x58, 0x58, 0xd1, 0xc6, 0xe6, 0xc0, 0xd1, 0x62, 0x5f, 0xd7, 0x29, 0x75, 0x0c, 0xd3, 0xd2,
	0x18, 0x51, 0x99, 0xa3, 0x59, 0xee, 0x25, 0x75, 0x26, 0xda, 0xc2, 0x1b, 0xe5, 0x57, 0x01, 0x36,
	0x1b, 0x1a, 0x23, 0x43, 0xea, 0xf8, 0xe8, 0x25, 0xac, 0x33, 0xdf, 0x26, 0xb2, 0xb0, 0x27, 0x94,
	0x0a, 0x95, 0x67, 0xe5, 0x85, 0xa7, 0xe5, 0x19, 0x66, 0xfe, 0xd0, 0xf3, 0x6d, 0x82, 0x39, 0x1c,
	0xed, 0x00, 0xe8, 0xd4, 0xba, 0x34, 0x0d, 0x62, 0xe9, 0x44, 0xce, 0xec, 0x09, 0x25, 0x01, 0xc7,
	0x24, 0xca, 0x18, 0xb6, 0xe2, 0x2c, 0x24, 0xc2, 0xfd, 0xb3, 0xf6, 0x71, 0xbb, 0xf3, 0xa6, 0x2d,
	0xdd, 0x43, 0x00, 0xd9, 0x5a, 0xbb, 0xd9, 0xaa, 0x9d, 0x48, 0x10, 0x3c, 0x9f, 0x1e, 0xe2, 0x6e,
	0xa7, 0x2d, 0x15, 0x03, 0x50, 0xbd, 0xd9, 0xe8, 0x37, 0x4e, 0x0e, 0xa5, 0x1d, 0x94, 0x87, 0x5c,
	0xab, 0xd3, 0xeb, 0xe0, 0x7a, 0xf3, 0xf8, 0x50, 0x2a, 0xa1, 0xfb, 0xb0, 0xd6, 0xa8, 0x61, 0xa9,
	0x12, 0x3c, 0xd4, 0xcf, 0xba, 0xd2, 0x97, 0x28, 0x07, 0x1b, 0x3d, 0x7c, 0xd6, 0x38, 0x96, 0x5e,
	0x29, 0x3f, 0x0a, 0x90, 0x6d, 0xd1, 0xc0, 0x69, 0xf4, 0x49, 0x22, 0x9e, 0xf7, 0xe2, 0xf1, 0x84,
	0x88, 0xe8, 0xe7, 0x6f, 0xc4, 0xf2, 0x12, 0x60, 0xc1, 0x59, 0x89, 0xa4, 0xd5, 0x79, 0xdd, 0x6c,
	0x7f, 0x25, 0x01, 0x2a, 0x00, 0x74, 0x7b, 0xb5, 0x5e, 0xb3, 0xd3, 0xae, 0xe1, 0xbe, 0x54, 0x54,
	0x26, 0x50, 0x38, 0xe0, 0x25, 0x6b, 0x11, 0xa6, 0x19, 0x1a, 0xd3, 0xd0, 0x73, 0xc8, 0x86, 0x45,
	0xe4, 0xde, 0x89, 0x15, 0xb1, 0x3c, 0xd2, 0xc6, 0xe5, 0x10, 0x84, 0x23, 0x15, 0xfa, 0x0c, 0x44,
	0x97, 0x58, 0x2e, 0x75, 0xd4, 0xa0, 0x29, 0xb8, 0x3b, 0x62, 0xe5, 0x71, 0x39, 0x68, 0x96, 0x72,
	0xd7, 0x77, 0x19, 0x99, 0xf4, 0x66, 0xcd, 0x82, 0x21, 0x44, 0x06, 0x02, 0xe5, 0x17, 0x01, 0x8a,
	0x0d, 0x6d, 0x42, 0x1c, 0x6d, 0xe9, 0xab, 0x0d, 0x78, 0x10, 0x9a, 0x56, 0x27, 0x91, 0x28, 0xfa,
	0xfc, 0x76, 0x3c, 0x39, 0x49, 0x12, 0x2e, 0x18, 0x49, 0x23, 0x1f, 0x01, 0x32, 0x27, 0xda, 0x90,
	0xa8, 0xdf, 0x98, 0x06, 0x1b, 0xa9, 0xb6, 0xe9, 0x91, 0xb1, 0xcb, 0x9d, 0xcb, 0x63, 0x89, 0x6b,
	0xde, 0x04, 0x8a, 0x53, 0x2e, 0x47, 0x65, 0x78, 0x14, 0xa2, 0x47, 0xc4, 0x1c, 0x8e, 0xd8, 0x0c,
	0xbe, 0xc6, 0xe1, 0x0f, 0xb9, 0xea, 0x88, 0x6b, 0x42, 0xbc, 0xf2, 0x7d, 0x06, 0x1e, 0x76, 0x06,
	0x5f, 0x13, 0x9d, 0xd5, 0xe9, 0xb5, 0x65, 0x98, 0xd6, 0xb0, 0x4e, 0x3d, 0xf4, 0x31, 0x6c, 0xea,
	0x51, 0x0f, 0x45, 0x1e, 0x17, 0x6f, 0x6a, 0x4f, 0x3c, 0x47, 0xa1, 0x0f, 0x21, 0x3b, 0xe1, 0x95,
	0x8a, 0xd2, 0x86, 0x56, 0xcb, 0x8f, 0x23, 0x04, 0x7a, 0x17, 0x80, 0x51, 0x5b, 0x1d, 0x93, 0x4b,
	0xa6, 0x7a, 0xdc, 0x35, 0x01, 0x6f, 0x32, 0x6a, 0x9f, 0x90, 0x4b, 0x76, 0x9e, 0xd0, 0xfa, 0xf2,
	0x7a, 0x42, 0xdb, 0x47, 0x4f, 0x21, 0x47, 0x3c, 0x46, 0x2c, 0xe6, 0xaa, 0x9e, 0xbc, 0x11, 0x2a,
	0x23, 0xc1, 0x79, 0x5c, 0xe9, 0xcb, 0xd9, 0x84, 0xb2, 0x8f, 0x76, 0x41, 0x34, 0x2d, 0x97, 0x69,
	0x96, 0x4e, 0x54, 0xd3, 0x90, 0xab, 0x3c, 0x23, 0x30, 0x13, 0x35, 0x0d, 0xe5, 0xbb, 0x2c, 0x3c,
	0x0a, 0x53, 0x51, 0x35, 0xfe, 0xbd, 0x64, 0x7c, 0x0e, 0xeb, 0x36, 0x75, 0x09, 0x4f, 0x83, 0x58,
	0x79, 0x51, 0x8e, 0x5d, 0x2a, 0xe5, 0xc6, 0xfc, 0x3a, 0xe9, 0x25, 0x6e, 0x13, 0xcc, 0x29, 0xc9,
	0x5c, 0xac, 0xdf, 0x96, 0x8b, 0x8d, 0xa5, 0x5c, 0xc4, 0x94, 0xd3, 0xa5, 0x44, 0x5d, 0xfc, 0x69,
	0xa2, 0xd0, 0xa7, 0xf0, 0xe4, 0xda, 0xd2, 0x89, 0xc3, 0x34, 0xd3, 0x62, 0xbe, 0x6a, 0x53, 0xd7,
	0x0c, 0xbc, 0x52, 0x3d, 0xf9, 0x3e, 0x37, 0x55, 0x8c, 0x69, 0x4f, 0x23, 0xe5, 0x79, 0x2a, 0xcb,
	0x97, 0x37, 0x53, 0x59, 0xfd, 0x54, 0xd6, 0x54, 0xce, 0xa5, 0xb2, 0x2e, 0x96, 0x59, 0x0e, 0x65,
	0x5a, 0xe4, 0x21, 0xac, 0xb0, 0x70, 0xa4, 0x3c, 0x4f, 0x65, 0xf9, 0xb2, 0x98, 0xca, 0xea, 0xa7,
	0xb2, 0xa6, 0xf2, 0x56, 0x2a, 0xeb, 0x02, 0x55, 0xe0, 0x71, 0x9c, 0xb5, 0xa8, 0x63, 0x9e, 0x93,
	0x1e, 0xc5, 0x94, 0x87, 0xb3, 0x92, 0xa6, 0x70, 0x7c, 0xb9, 0x90, 0xc6, 0xe9, 0xa7, 0x71, 0xa6,
	0xf2, 0x83, 0x34, 0xce, 0x85, 0xf2, 0xed, 0x06, 0xa0, 0xd9, 0x41, 0x68, 0x50, 0xeb, 0x2d, 0xf1,
	0x8e, 0xae, 0xc7, 0xe3, 0xbb, 0x7b, 0x0e, 0x0a, 0x90, 0xf1, 0x5c, 0x79, 0x7d, 0x6f, 0xad, 0x24,
	0xe0, 0x8c, 0xe7, 0xde, 0xde, 0xfa, 0x05, 0xc8, 0x4c, 0x5d, 0x39, 0x1b, 0x82, 0xa7, 0xee, 0xff,
	0xdd, 0xfe, 0x1f, 0x76, 0xfb, 0x6d, 0x9d, 0xab, 0xfc, 0x2e, 0xc0, 0x3b, 0xe1, 0x54, 0xad, 0x8d,
	0xcd, 0xa1, 0x45, 0x8c, 0x3a, 0xf5, 0x0e, 0x66, 0xdb, 0x1d, 0x7a, 0x0d, 0x4f, 0x74, 0xae, 0x54,
	0x6f, 0x9e, 0xb0, 0x7b, 0xc9, 0xd6, 0x5c, 0x1d, 0xce, 0xb8, 0xa8, 0xdf, 0x34, 0xb2, 0x83, 0x1d,
	0x80, 0x8f, 0xfa, 0xbf, 0xb4, 0x03, 0xcc, 0x05, 0xe8, 0x00, 0x0a, 0x83, 0x68, 0x66, 0xa8, 0x03,
	0xea, 0x91, 0x60, 0xe4, 0xae, 0x95, 0xc4, 0xe4, 0x1a, 0xb4, 0x32, 0x68, 0x71, 0x7e, 0xb0, 0x78,
	0x21, 0xae, 0xf2, 0x73, 0x06, 0x9e, 0x26, 0x62, 0xae, 0xde, 0xed, 0xa8, 0x5f, 0xa5, 0x44, 0xbd,
	0xbb, 0x1a, 0x75, 0x62, 0xa6, 0x2e, 0xc5, 0x8d, 0x6a, 0xb0, 0xa5, 0xf3, 0x8b, 0x46, 0x1d, 0x5d,
	0x8f, 0xc7, 0xe1, 0x59, 0x16, 0x2b, 0x3b, 0x37, 0x59, 0x59, 0x5c, 0x48, 0x58, 0xd4, 0xe7, 0xcf,
	0xae, 0xf2, 0x93, 0x30, 0x5b, 0x64, 0xba, 0x24, 0xb8, 0x1d, 0xf4, 0x96, 0xe6, 0x5e, 0xfd, 0xc3,
	0x77, 0x56, 0x09, 0x24, 0xbe, 0x5f, 0xa9, 0x9e, 0xaf, 0x9a, 0x96, 0x61, 0xea, 0x51, 0x02, 0xf2,
	0xb8, 0xc0, 0xe5, 0xe7, 0x7e, 0x33, 0x94, 0x2a, 0xbf, 0x09, 0xf0, 0x38, 0xac, 0x47, 0xb8, 0x77,
	0xdd, 0xdd, 0x92, 0x56, 0x61, 0x63, 0xa2, 0xb9, 0x57, 0xb7, 0xf4, 0x6f, 0x2c, 0xbf, 0x38, 0xc4,
	0x2a, 0x3f, 0x64, 0x20, 0xb7, 0x08, 0xe9, 0x04, 0xf2, 0x03, 0xea, 0xa9, 0xf3, 0xbf, 0x62, 0x51,
	0x24, 0x2f, 0x56, 0x23, 0xb9, 0xe1, 0x64, 0x1f, 0xdd, 0xc3, 0x5b, 0x83, 0x78, 0xcf, 0x77, 0x41,
	0x0a, 0xac, 0x55, 0x8d, 0x98, 0xc1, 0x30, 0x9a, 0xf7, 0x53, 0x0d, 0x56, 0x97, 0x4d, 0x16, 0x06,
	0xd4, 0xab, 0x1a, 0x0b, 0xa3, 0xed, 0xa8, 0x72, 0x6e, 0xcc, 0x68, 0x38, 0x79, 0x9e, 0xad, 0x1a,
	0x5d, 0x2a, 0xd9, 0xd1, 0x3d, 0xfc, 0xc0, 0x4e, 0x8a, 0xea, 0x22, 0xe4, 0xe6, 0x86, 0x06, 0x59,
	0xfe, 0x67, 0xaf, 0xfa, 0x47, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5b, 0x11, 0xe4, 0xc0, 0xa7, 0x0e,
	0x00, 0x00,
}
